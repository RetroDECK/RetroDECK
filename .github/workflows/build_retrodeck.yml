name: Build Flatpak

on:
  workflow_dispatch:
    inputs:
      branch_override:
        description: 'Branch to build (leave empty to use current branch)'
        required: false
        type: string

      epicure_mode:
        description: 'Build as Epicure (uses main code + epicure components)'
        required: false
        type: boolean
        default: false

      components_release_override:
        description: 'Components release tag override (leave empty for auto-detect)'
        required: false
        type: string

      publish_to_flathub:
        description: 'Publish to Flathub (main/epicure only, after validation)'
        required: false
        type: boolean
        default: false

      dry_run:
        description: 'Dry run - build and validate but do not create releases or push to Flathub'
        required: false
        type: boolean
        default: true

      # Internal - set by cross-repo triggers from components repo
      triggered_by_components:
        description: 'INTERNAL WORKFLOW USE - set when triggered by components repo'
        required: false
        type: boolean
        default: false

      components_branch:
        description: 'INTERNAL WORKFLOW USE - branch that was built in components repo'
        required: false
        type: string

      components_release_tag:
        description: 'INTERNAL WORKFLOW USE - components release tag from trigger'
        required: false
        type: string

  push:
    branches:
      - main
      - cooker

permissions:
  contents: write

env:
  COMPONENTS_REPO: ${{ github.repository_owner }}/components
  COOKER_REPO: ${{ github.repository_owner }}/Cooker
  APP_ID: net.retrodeck.retrodeck

jobs:
  # ===========================================================================
  # Check whether this push event should trigger a build
  # ===========================================================================
  check-trigger:
    name: Check Build Trigger
    runs-on: ubuntu-latest
    outputs:
      should_build: ${{ steps.check.outputs.should_build }}
      trigger_type: ${{ steps.check.outputs.trigger_type }}
      publish_flathub: ${{ steps.check.outputs.publish_flathub }}
      is_dry_run: ${{ steps.check.outputs.is_dry_run }}
    steps:
      - name: Checkout code
        if: github.event_name == 'push'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Evaluate trigger
        id: check
        run: |
          # Trigger words for commit message detection
          BUILD_TRIGGER="build"
          RELEASE_TRIGGER="release"
          DRY_RUN_TRIGGER="dry-run"

          # Manual or components-repo-triggered dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ inputs.triggered_by_components }}" == "true" ]]; then
              # Cross-repo trigger from components workflow
              echo "trigger_type=cross-repo" >> $GITHUB_OUTPUT
              echo "should_build=true" >> $GITHUB_OUTPUT
              echo "is_dry_run=false" >> $GITHUB_OUTPUT

              # Epicure cross-repo triggers auto-publish to Flathub beta
              if [[ "${{ inputs.components_branch }}" == "epicure" ]]; then
                echo "publish_flathub=true" >> $GITHUB_OUTPUT
                echo "Cross-repo trigger from epicure - will publish to Flathub beta"
              else
                echo "publish_flathub=false" >> $GITHUB_OUTPUT
                echo "Cross-repo trigger from components"
              fi
              exit 0
            fi

            # Standard manual trigger
            echo "trigger_type=manual" >> $GITHUB_OUTPUT
            echo "should_build=true" >> $GITHUB_OUTPUT

            if [[ "${{ inputs.dry_run }}" == "true" ]]; then
              echo "is_dry_run=true" >> $GITHUB_OUTPUT
            else
              echo "is_dry_run=false" >> $GITHUB_OUTPUT
            fi

            if [[ "${{ inputs.publish_to_flathub }}" == "true" ]]; then
              echo "publish_flathub=true" >> $GITHUB_OUTPUT
            else
              echo "publish_flathub=false" >> $GITHUB_OUTPUT
            fi
            exit 0
          fi

          # Push event: check commit messages for trigger words
          echo "trigger_type=push" >> $GITHUB_OUTPUT

          COMMITS=$(git log --format=%B ${{ github.event.before }}..${{ github.event.after }})

          # PR merge commits always trigger a build (no trigger word needed)
          if echo "$COMMITS" | grep -qiE "^Merge pull request #"; then
            echo "PR merge detected - auto-building"
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "publish_flathub=false" >> $GITHUB_OUTPUT
            echo "is_dry_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # [dry-run] -> build only, no release
          if echo "$COMMITS" | grep -qiE "\[${DRY_RUN_TRIGGER}\]"; then
            echo "Found [dry-run] trigger in commit messages"
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "publish_flathub=false" >> $GITHUB_OUTPUT
            echo "is_dry_run=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # [release] -> build + publish to Flathub (main branch only)
          if echo "$COMMITS" | grep -qiE "\[${RELEASE_TRIGGER}\]"; then
            if [[ "${{ github.ref_name }}" == "main" ]]; then
              echo "Found [release] trigger on main branch"
              echo "should_build=true" >> $GITHUB_OUTPUT
              echo "publish_flathub=true" >> $GITHUB_OUTPUT
              echo "is_dry_run=false" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "Found [release] trigger but ignoring - only allowed on main branch"
              echo "Treating as [build] trigger instead"
            fi
          fi

          # [build] -> build only
          if echo "$COMMITS" | grep -qiE "\[${BUILD_TRIGGER}\]"; then
            echo "Found [build] trigger in commit messages"
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "publish_flathub=false" >> $GITHUB_OUTPUT
            echo "is_dry_run=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # No trigger found
          echo "No build trigger found in commit messages - skipping"
          echo "should_build=false" >> $GITHUB_OUTPUT
          echo "publish_flathub=false" >> $GITHUB_OUTPUT
          echo "is_dry_run=false" >> $GITHUB_OUTPUT

  # ===========================================================================
  # Validate inputs and determine all build parameters
  # ===========================================================================
  configure:
    name: Configure Build
    needs: check-trigger
    if: needs.check-trigger.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    outputs:
      branch: ${{ steps.config.outputs.branch }}
      is_epicure: ${{ steps.config.outputs.is_epicure }}
      components_release: ${{ steps.components.outputs.release_tag }}
      build_variants: ${{ steps.config.outputs.build_variants }}
      release_repo: ${{ steps.config.outputs.release_repo }}
      publish_flathub: ${{ steps.flathub.outputs.publish_flathub }}
      is_dry_run: ${{ needs.check-trigger.outputs.is_dry_run }}
    steps:
      - name: Determine build parameters
        id: config
        run: |
          TRIGGER_TYPE="${{ needs.check-trigger.outputs.trigger_type }}"
          IS_EPICURE="false"

          # Determine branch and epicure status
          if [[ "$TRIGGER_TYPE" == "cross-repo" ]]; then
            COMPONENTS_BRANCH="${{ inputs.components_branch }}"

            if [[ "$COMPONENTS_BRANCH" == "epicure" ]]; then
              BRANCH="main"
              IS_EPICURE="true"
            else
              BRANCH="$COMPONENTS_BRANCH"
            fi
          elif [[ "$TRIGGER_TYPE" == "manual" ]]; then
            if [[ "${{ inputs.epicure_mode }}" == "true" ]]; then
              BRANCH="main"
              IS_EPICURE="true"
            elif [[ -n "${{ inputs.branch_override }}" ]]; then
              BRANCH="${{ inputs.branch_override }}"
            else
              BRANCH="${{ github.ref_name }}"
            fi
          else
            # Push trigger
            BRANCH="${{ github.ref_name }}"
          fi

          # Determine release destination repo
          # main and epicure -> RetroDECK repo
          # cooker and feature branches -> cooker repo
          if [[ "$BRANCH" == "main" || "$IS_EPICURE" == "true" ]]; then
            RELEASE_REPO="${{ github.repository }}"
          else
            RELEASE_REPO="$COOKER_REPO"
          fi

          # Determine build variants
          # Only cooker builds both full and countertop
          if [[ "$BRANCH" == "cooker" && "$IS_EPICURE" == "false" ]]; then
            BUILD_VARIANTS='["full", "countertop"]'
          else
            BUILD_VARIANTS='["full"]'
          fi

          # Write outputs
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "is_epicure=$IS_EPICURE" >> $GITHUB_OUTPUT
          echo "release_repo=$RELEASE_REPO" >> $GITHUB_OUTPUT
          echo "build_variants=$BUILD_VARIANTS" >> $GITHUB_OUTPUT

          echo ""
          echo "=========================================="
          echo "Build Configuration"
          echo "=========================================="
          echo "  Trigger type:       $TRIGGER_TYPE"
          echo "  Branch:             $BRANCH"
          echo "  Is epicure:         $IS_EPICURE"
          echo "  Release repo:       $RELEASE_REPO"
          echo "  Build variants:     $BUILD_VARIANTS"
          echo "  Dry run:            ${{ needs.check-trigger.outputs.is_dry_run }}"
          echo "=========================================="

      - name: Determine components release
        id: components
        run: |
          TRIGGER_TYPE="${{ needs.check-trigger.outputs.trigger_type }}"
          IS_EPICURE="${{ steps.config.outputs.is_epicure }}"
          BRANCH="${{ steps.config.outputs.branch }}"

          # Priority: cross-repo tag > manual override > auto-detect
          if [[ "$TRIGGER_TYPE" == "cross-repo" && -n "${{ inputs.components_release_tag }}" ]]; then
            COMPONENTS_TAG="${{ inputs.components_release_tag }}"
            echo "Using components release from cross-repo trigger: $COMPONENTS_TAG"
          elif [[ -n "${{ inputs.components_release_override }}" ]]; then
            COMPONENTS_TAG="${{ inputs.components_release_override }}"
            echo "Using components release from manual override: $COMPONENTS_TAG"
          else
            # Auto-detect most recent components release for matching branch
            if [[ "$IS_EPICURE" == "true" ]]; then
              SEARCH_PREFIX="epicure"
            else
              SEARCH_PREFIX="$BRANCH"
            fi

            echo "Auto-detecting components release for prefix: $SEARCH_PREFIX"

            COMPONENTS_TAG=$(gh release list \
              --repo "$COMPONENTS_REPO" \
              --limit 100 \
              --json tagName \
              -q "[.[] | select(.tagName | startswith(\"${SEARCH_PREFIX}-\"))] | .[0].tagName")

            if [[ -z "$COMPONENTS_TAG" || "$COMPONENTS_TAG" == "null" ]]; then
              echo "ERROR: No components release found for prefix: $SEARCH_PREFIX"
              exit 1
            fi
            echo "Auto-detected components release: $COMPONENTS_TAG"
          fi

          echo "release_tag=$COMPONENTS_TAG" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Validate Flathub publication
        id: flathub
        run: |
          REQUESTED="${{ needs.check-trigger.outputs.publish_flathub }}"
          BRANCH="${{ steps.config.outputs.branch }}"
          IS_EPICURE="${{ steps.config.outputs.is_epicure }}"

          # Flathub publication is only allowed for main and epicure
          if [[ "$REQUESTED" == "true" ]]; then
            if [[ "$BRANCH" == "main" || "$IS_EPICURE" == "true" ]]; then
              echo "publish_flathub=true" >> $GITHUB_OUTPUT
              echo "Flathub publication enabled"
            else
              echo "publish_flathub=false" >> $GITHUB_OUTPUT
              echo "Flathub publication not allowed for branch: $BRANCH (main/epicure only)"
            fi
          else
            echo "publish_flathub=false" >> $GITHUB_OUTPUT
            echo "Flathub publication not requested"
          fi

  # ===========================================================================
  # Validate source files
  # ===========================================================================
  validate:
    name: Validate Sources
    needs: configure
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.configure.outputs.branch }}

      - name: Validate Bash scripts
        run: |
          echo "Validating Bash scripts..."

          ERRORS=0
          while IFS= read -r script; do
            if ! bash -n "$script" 2>/dev/null; then
              echo "FAILED: $script"
              ERRORS=$((ERRORS + 1))
            fi
          done < <(find . -type f -name "*.sh")

          if [[ "$ERRORS" -gt 0 ]]; then
            echo "ERROR: $ERRORS script(s) failed syntax validation"
            exit 1
          fi

          echo "All Bash scripts passed syntax validation"

      - name: Validate JSON files
        run: |
          echo "Validating JSON files..."

          ERRORS=0
          while IFS= read -r json; do
            if ! jq empty "$json" 2>/dev/null; then
              echo "FAILED: $json"
              ERRORS=$((ERRORS + 1))
            fi
          done < <(find . -type f -name "*.json")

          if [[ "$ERRORS" -gt 0 ]]; then
            echo "ERROR: $ERRORS JSON file(s) failed validation"
            exit 1
          fi

          echo "All JSON files passed validation"

  # ===========================================================================
  # Build the Flatpak bundle(s)
  # ===========================================================================
  build:
    name: Build Flatpak (${{ matrix.variant }})
    needs: [configure, validate]
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.build.outputs.version }}
    strategy:
      matrix:
        variant: ${{ fromJSON(needs.configure.outputs.build_variants) }}
      fail-fast: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.configure.outputs.branch }}

      - name: Free Disk Space (Ubuntu)
        uses: jlumbroso/free-disk-space@main
        with:
          # this might remove tools that are actually needed,
          # if set to "true" but frees about 6 GB
          tool-cache: false
          
          # all of these default to true, but feel free to set to
          # "false" if necessary for your workflow
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: true

      - name: Install build dependencies
        run: |
          echo "Installing build dependencies..."

          unset pkg_mgr
          for candidate in apt pacman dnf; do
            command -v "$candidate" &> /dev/null && pkg_mgr="$candidate" && break
          done

          case "${pkg_mgr:-}" in
            apt)
              sudo add-apt-repository -y ppa:flatpak/stable
              sudo apt update
              sudo apt install -y flatpak flatpak-builder xmlstarlet jq
              ;;
            pacman)
              sudo pacman -Sy --noconfirm flatpak flatpak-builder libxml2 jq
              ;;
            dnf)
              sudo dnf install -y flatpak flatpak-builder xmlstarlet jq
              ;;
            *)
              echo "ERROR: No supported package manager found (apt, pacman, dnf)"
              exit 1
              ;;
          esac

          flatpak remote-add --user --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
          flatpak remote-add --user --if-not-exists flathub-beta https://flathub.org/beta-repo/flathub-beta.flatpakrepo

          echo "Build dependencies installed"

      - name: Generate application sources
        run: |
          REPO_URL="https://github.com/${{ github.repository }}.git"
          COMMIT="${{ github.sha }}"

          echo "Generating application-sources.json"
          echo "  Repository: $REPO_URL"
          echo "  Commit:     $COMMIT"

          cat > application-sources.json <<EOF
          [
            {
              "type": "git",
              "url": "$REPO_URL",
              "commit": "$COMMIT"
            }
          ]
          EOF

      - name: Download components sources
        run: |
          COMPONENTS_TAG="${{ needs.configure.outputs.components_release }}"

          echo "Downloading components-sources.json from release: $COMPONENTS_TAG"

          gh release download "$COMPONENTS_TAG" \
            --repo "$COMPONENTS_REPO" \
            -p "components-sources.json" \
            -D .

          COMPONENT_COUNT=$(jq 'length' components-sources.json)
          echo "Components in sources file: $COMPONENT_COUNT"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Update metainfo release date
        if: needs.configure.outputs.publish_flathub == 'true'
        run: |
          METAINFO_FILE="${APP_ID}.metainfo.xml"
          TODAY=$(date -u +"%Y-%m-%d")
          BRANCH="${{ needs.configure.outputs.branch }}"
          IS_EPICURE="${{ needs.configure.outputs.is_epicure }}"

          echo "Updating metainfo release date to $TODAY"

          xmlstarlet ed --inplace \
            -u '//releases/release[1]/@date' \
            -v "$TODAY" \
            "$METAINFO_FILE"

          # Commit to main branch only (epicure leaves it ephemeral)
          if [[ "$BRANCH" == "main" && "$IS_EPICURE" == "false" ]]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add "$METAINFO_FILE"

            if ! git diff --staged --quiet; then
              git commit -m "Update release date in metainfo [skip ci]"
              git push
              echo "Committed and pushed metainfo update"
            else
              echo "No changes needed (date already current)"
            fi
          else
            echo "Metainfo updated ephemerally (not committed)"
          fi

      - name: Build flatpak bundle
        id: build
        run: |
          IS_EPICURE="${{ needs.configure.outputs.is_epicure }}"
          VARIANT="${{ matrix.variant }}"

          if [[ "$IS_EPICURE" == "true" ]]; then
            BUILD_TYPE="epicure"
          else
            BUILD_TYPE="$VARIANT"
          fi

          echo "Building flatpak bundle..."
          echo "  Variant:    $VARIANT"
          echo "  Build type: $BUILD_TYPE"

          ./automation-tools/build/builder.sh --build-flatpak "$BUILD_TYPE"

          echo "Build complete"

      - name: Verify build output
        run: |
          if [[ ! -d "output" ]]; then
            echo "ERROR: output directory not created by builder"
            exit 1
          fi

          echo "Build artifacts:"
          ls -lh output/

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: flatpak-artifacts-${{ matrix.variant }}
          path: |
            output/
            components-sources.json
            application-sources.json
          retention-days: 1
          if-no-files-found: error

  # ===========================================================================
  # Create a GitHub release
  # ===========================================================================
  create-release:
    name: Create Release
    needs: [check-trigger, configure, build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.configure.outputs.branch }}

      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: downloaded-artifacts/
          pattern: 'flatpak-artifacts-*'

      - name: Collect release assets
        id: collect
        run: |
          mkdir -p release-assets

          find downloaded-artifacts/ -type f | while read -r file; do
            cp "$file" release-assets/
          done

          echo "Release assets:"
          ls -lh release-assets/

          ASSET_COUNT=$(ls release-assets/ | wc -l)
          echo "asset_count=$ASSET_COUNT" >> $GITHUB_OUTPUT

      - name: Determine release parameters
        id: release
        run: |
          VERSION="${{ needs.build.outputs.version }}"
          BRANCH="${{ needs.configure.outputs.branch }}"
          IS_EPICURE="${{ needs.configure.outputs.is_epicure }}"
          PUBLISH_FLATHUB="${{ needs.configure.outputs.publish_flathub }}"
          RELEASE_REPO="${{ needs.configure.outputs.release_repo }}"

          # Tag is always the version string (prefixed by builder.sh per branch type)
          RELEASE_TAG="$VERSION"
          TITLE="${{ github.repository_owner }} ${{ github.event.repository.name }} ${RELEASE_TAG}"

          # Determine release flags based on branch type and trigger
          #   main + [release]  -> latest (production)
          #   main + [build]    -> draft
          #   epicure           -> pre-release
          #   cooker            -> pre-release
          #   feature branches  -> draft

          IS_LATEST="false"
          IS_PRERELEASE="false"
          IS_DRAFT="false"
          RELEASE_TYPE=""

          if [[ "$IS_EPICURE" == "true" ]]; then
            IS_PRERELEASE="true"
            RELEASE_TYPE="Pre-release (Epicure)"
          elif [[ "$BRANCH" == "main" ]]; then
            if [[ "$PUBLISH_FLATHUB" == "true" ]]; then
              IS_LATEST="true"
              RELEASE_TYPE="Latest"
            else
              IS_DRAFT="true"
              RELEASE_TYPE="Draft"
            fi
          elif [[ "$BRANCH" == "cooker" ]]; then
            IS_PRERELEASE="true"
            RELEASE_TYPE="Pre-release (Cooker)"
          else
            IS_DRAFT="true"
            RELEASE_TYPE="Draft (${BRANCH})"
          fi

          echo "tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "is_latest=$IS_LATEST" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          echo "is_draft=$IS_DRAFT" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT

          echo ""
          echo "=========================================="
          echo "Release Parameters"
          echo "=========================================="
          echo "  Tag:        $RELEASE_TAG"
          echo "  Title:      $TITLE"
          echo "  Type:       $RELEASE_TYPE"
          echo "  Repository: $RELEASE_REPO"
          echo "  Branch:     $BRANCH"
          echo "=========================================="

      - name: Generate release notes
        run: |
          # Install xmlstarlet for metainfo extraction
          sudo apt install -y xmlstarlet

          RELEASE_TAG="${{ steps.release.outputs.tag }}"
          BRANCH="${{ needs.configure.outputs.branch }}"
          IS_EPICURE="${{ needs.configure.outputs.is_epicure }}"
          COMPONENTS_RELEASE="${{ needs.configure.outputs.components_release }}"
          METAINFO_FILE="${APP_ID}.metainfo.xml"
          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          # Extract changelog URL from metainfo
          CHANGELOG_URL=""
          if [[ -f "$METAINFO_FILE" ]]; then
            CHANGELOG_URL=$(xmlstarlet sel -t -v "/component/releases/release[1]/url" "$METAINFO_FILE" 2>/dev/null || true)
          fi

          # Download components release metadata for changed component info
          COMPONENTS_METADATA_URL="https://github.com/${COMPONENTS_REPO}/releases/download/${COMPONENTS_RELEASE}"
          CHANGED_COMPONENTS=""

          if gh release download "$COMPONENTS_RELEASE" \
            --repo "$COMPONENTS_REPO" \
            -p "release_metadata.json" \
            -D . 2>/dev/null; then

            CHANGED_COMPONENTS=$(jq -r '
              to_entries
              | map(select(.value.status == "new"))
              | sort_by(.key)
              | .[]
              | "- **\(.key)**: \(.value.version)"
            ' release_metadata.json)
          fi

          # Build release notes
          cat > release_notes.md <<EOF
          ## Flatpak Release - ${RELEASE_TAG}

          **Built On:** ${TIMESTAMP}
          **Branch:** \`${BRANCH}\`
          EOF

          if [[ "$IS_EPICURE" == "true" ]]; then
            echo "**Type:** Epicure" >> release_notes.md
          fi

          cat >> release_notes.md <<EOF
          **Commit:** \`${{ github.sha }}\`
          **Components Release:** ${COMPONENTS_RELEASE}
          EOF

          if [[ -n "$CHANGELOG_URL" ]]; then
            echo "**Changelog:** [View changelog](${CHANGELOG_URL})" >> release_notes.md
          fi

          cat >> release_notes.md <<EOF

          ---

          EOF

          # Changed components section
          if [[ -n "$CHANGED_COMPONENTS" ]]; then
            cat >> release_notes.md <<EOF
          ### Updated Components

          ${CHANGED_COMPONENTS}

          EOF
          fi

          echo "**Components sources:** [components-sources.json](${COMPONENTS_METADATA_URL}/components-sources.json)" >> release_notes.md
          echo "" >> release_notes.md

          # Cooker variant info
          if [[ "$BRANCH" == "cooker" ]]; then
            cat >> release_notes.md <<EOF
          ### Variants

          This release includes two flatpak variants:

          - **Full**: Complete installation with all components
          - **Countertop**: Lightweight installation with only core components

          EOF
          fi

          # Flathub info
          if [[ "${{ needs.configure.outputs.publish_flathub }}" == "true" ]]; then
            if [[ "$IS_EPICURE" == "true" ]]; then
              echo "### Flathub" >> release_notes.md
              echo "" >> release_notes.md
              echo "This release will be published to **Flathub Beta** channel." >> release_notes.md
            else
              echo "### Flathub" >> release_notes.md
              echo "" >> release_notes.md
              echo "This release will be published to **Flathub** main channel." >> release_notes.md
            fi
            echo "" >> release_notes.md
          fi

          # Asset list
          echo "### Assets" >> release_notes.md
          echo "" >> release_notes.md

          for asset in release-assets/*; do
            ASSET_NAME=$(basename "$asset")
            ASSET_SIZE=$(du -h "$asset" | cut -f1)
            if [[ "$ASSET_NAME" == *.flatpak ]]; then
              echo "- **${ASSET_NAME}** (${ASSET_SIZE}) - Flatpak bundle" >> release_notes.md
            elif [[ "$ASSET_NAME" == *.sha ]]; then
              echo "- **${ASSET_NAME}** - SHA256 checksum" >> release_notes.md
            fi
          done

          echo "Release notes generated"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Create release
        if: needs.configure.outputs.is_dry_run == 'false'
        run: |
          RELEASE_TAG="${{ steps.release.outputs.tag }}"
          TITLE="${{ steps.release.outputs.title }}"
          RELEASE_REPO="${{ needs.configure.outputs.release_repo }}"

          # Build gh release flags
          FLAGS=""
          [[ "${{ steps.release.outputs.is_draft }}" == "true" ]] && FLAGS="$FLAGS --draft"
          [[ "${{ steps.release.outputs.is_prerelease }}" == "true" ]] && FLAGS="$FLAGS --prerelease"
          [[ "${{ steps.release.outputs.is_latest }}" == "true" ]] && FLAGS="$FLAGS --latest"

          # Use cross-repo token when publishing to a different repo
          if [[ "$RELEASE_REPO" != "${{ github.repository }}" ]]; then
            export GH_TOKEN="${{ secrets.FLATPAK_REPO_API_REQUESTS }}"
          else
            export GH_TOKEN="${{ github.token }}"
          fi

          echo "Creating release..."
          echo "  Repository: $RELEASE_REPO"
          echo "  Tag:        $RELEASE_TAG"
          echo "  Title:      $TITLE"

          gh release create "$RELEASE_TAG" \
            --repo "$RELEASE_REPO" \
            --title "$TITLE" \
            --notes-file release_notes.md \
            $FLAGS \
            release-assets/*

          echo ""
          echo "=========================================="
          echo "Release created"
          echo "  URL: https://github.com/${RELEASE_REPO}/releases/tag/${RELEASE_TAG}"
          echo "=========================================="

      - name: Dry-run summary
        if: needs.configure.outputs.is_dry_run == 'true'
        run: |
          RELEASE_TAG="${{ steps.release.outputs.tag }}"
          TITLE="${{ steps.release.outputs.title }}"
          RELEASE_REPO="${{ needs.configure.outputs.release_repo }}"
          RELEASE_TYPE="${{ steps.release.outputs.release_type }}"

          echo "=========================================="
          echo "DRY RUN - Release Preview"
          echo "=========================================="
          echo ""
          echo "Release would be created with:"
          echo "  Repository: $RELEASE_REPO"
          echo "  Tag:        $RELEASE_TAG"
          echo "  Title:      $TITLE"
          echo "  Type:       $RELEASE_TYPE"
          echo ""
          echo "Assets:"
          for asset in release-assets/*; do
            echo "  - $(basename "$asset") ($(du -h "$asset" | cut -f1))"
          done
          echo ""
          echo "Release notes:"
          echo "------------------------------------------"
          cat release_notes.md
          echo "------------------------------------------"
          echo ""
          echo "Dry-run complete - no release was created"
          echo "=========================================="

  # ===========================================================================
  # Publish to Flathub (main/epicure only)
  # ===========================================================================
  publish-flathub:
    name: Publish to Flathub
    needs: [configure, build, create-release]
    if: needs.configure.outputs.publish_flathub == 'true' && needs.configure.outputs.is_dry_run == 'false'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout flatpak repo (main branch)
        uses: actions/checkout@v4
        with:
          ref: main
          path: flatpak-repo

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: flatpak-artifacts-full
          path: downloaded-artifacts/

      - name: Install Flatpak
        run: |
          echo "Installing Flatpak..."

          unset pkg_mgr
          for candidate in apt pacman dnf; do
            command -v "$candidate" &> /dev/null && pkg_mgr="$candidate" && break
          done

          case "${pkg_mgr:-}" in
            apt)
              sudo add-apt-repository -y ppa:flatpak/stable
              sudo apt update
              sudo apt install -y flatpak
              ;;
            pacman)
              sudo pacman -Sy --noconfirm flatpak
              ;;
            dnf)
              sudo dnf install -y flatpak
              ;;
            *)
              echo "ERROR: No supported package manager found (apt, pacman, dnf)"
              exit 1
              ;;
          esac

          flatpak remote-add --user --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo

          echo "Flatpak installed"

      - name: Install Flathub builder
        run: |
          flatpak install -y --user flathub org.flatpak.Builder
          echo "Flathub builder installed"

      - name: Prepare source files for validation
        run: |
          cp downloaded-artifacts/components-sources.json flatpak-repo/components-sources.json
          cp downloaded-artifacts/application-sources.json flatpak-repo/application-sources.json
          echo "Source files staged for validation"

      - name: Test build with Flathub buildbot
        run: |
          MANIFEST="${APP_ID}.yml"

          echo "Testing build with Flathub buildbot..."
          echo "  Manifest: $MANIFEST"

          cd flatpak-repo
          flatpak run --command=flathub-build org.flatpak.Builder "$MANIFEST"

          echo "Flathub build test passed"

      - name: Lint build with Flathub linter
        run: |
          EXCEPTIONS_FILE="flatpak-repo/automation-tools/flathub-lint-exceptions.json"

          echo "Running Flathub linter..."

          cd flatpak-repo
          LINT_OUTPUT=$(flatpak run --command=flatpak-builder-lint \
            org.flatpak.Builder repo repo 2>&1) || true

          echo "Linter output:"
          echo "$LINT_OUTPUT"

          ERRORS=$(echo "$LINT_OUTPUT" | jq -r '.errors // [] | .[]')

          if [[ -z "$ERRORS" ]]; then
            echo "No linter errors found"
            exit 0
          fi

          cd ..

          if [[ ! -f "$EXCEPTIONS_FILE" ]]; then
            echo "ERROR: Exceptions file not found: $EXCEPTIONS_FILE"
            exit 1
          fi

          echo "Checking errors against approved exceptions..."

          UNAPPROVED=()
          while IFS= read -r error; do
            [[ -z "$error" ]] && continue

            IS_APPROVED=$(jq -r --arg e "$error" \
              'if index($e) != null then "true" else "false" end' \
              "$EXCEPTIONS_FILE")

            if [[ "$IS_APPROVED" == "true" ]]; then
              echo "  Approved exception: $error"
            else
              echo "  Unapproved error:   $error"
              UNAPPROVED+=("$error")
            fi
          done <<< "$ERRORS"

          if [[ "${#UNAPPROVED[@]}" -gt 0 ]]; then
            echo ""
            echo "=========================================="
            echo "FAILED: ${#UNAPPROVED[@]} unapproved linter error(s)"
            for error in "${UNAPPROVED[@]}"; do
              echo "  - $error"
            done
            echo ""
            echo "See https://docs.flathub.org/linter for details"
            echo "Add approved exceptions to: $EXCEPTIONS_FILE"
            echo "=========================================="
            exit 1
          fi

          echo "All linter errors are approved exceptions - validation passed"

      - name: Determine Flathub target
        id: flathub
        run: |
          IS_EPICURE="${{ needs.configure.outputs.is_epicure }}"
          VERSION="${{ needs.build.outputs.version }}"
          FLATHUB_REPO="flathub/${APP_ID}"

          if [[ "$IS_EPICURE" == "true" ]]; then
            FLATHUB_BRANCH="beta"
          else
            FLATHUB_BRANCH="master"
          fi

          echo "flathub_branch=$FLATHUB_BRANCH" >> $GITHUB_OUTPUT
          echo "flathub_repo=$FLATHUB_REPO" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT

          echo ""
          echo "=========================================="
          echo "Flathub Publish Parameters"
          echo "=========================================="
          echo "  Flathub repo:   $FLATHUB_REPO"
          echo "  Flathub branch: $FLATHUB_BRANCH"
          echo "  Version:        $VERSION"
          echo "=========================================="

      - name: Clone Flathub repo
        run: |
          FLATHUB_REPO="${{ steps.flathub.outputs.flathub_repo }}"
          FLATHUB_BRANCH="${{ steps.flathub.outputs.flathub_branch }}"

          git clone \
            --branch "$FLATHUB_BRANCH" \
            --depth 1 \
            "https://github.com/${FLATHUB_REPO}.git" \
            flathub-repo

          echo "Cloned Flathub repo (branch: $FLATHUB_BRANCH)"

      - name: Prepare and push to Flathub
        run: |
          VERSION="${{ steps.flathub.outputs.version }}"
          FLATHUB_REPO="${{ steps.flathub.outputs.flathub_repo }}"
          MANIFEST_FILE="${APP_ID}.yml"

          cd flathub-repo

          # Configure git
          git config user.name "${{ secrets.GITNAME }}"
          git config user.email "${{ secrets.GITMAIL }}"

          # Create version branch
          git checkout -b "$VERSION"

          # Copy files
          cp "../flatpak-repo/${MANIFEST_FILE}" "$MANIFEST_FILE"
          echo "$VERSION" > version
          cp ../downloaded-artifacts/application-sources.json application-sources.json
          cp ../downloaded-artifacts/components-sources.json components-sources.json

          # Stage and commit
          git add \
            "$MANIFEST_FILE" \
            version \
            application-sources.json \
            components-sources.json

          if ! git diff --staged --quiet; then
            git commit -m "Update to version ${VERSION}"
          else
            echo "No changes detected - files may already be up to date"
          fi

          # Push
          git remote set-url origin "https://x-access-token:${{ secrets.FLATHUB_PUSH }}@github.com/${FLATHUB_REPO}"
          git push --force origin "$VERSION"

          echo ""
          echo "=========================================="
          echo "Pushed to Flathub"
          echo "  Repository: $FLATHUB_REPO"
          echo "  Branch:     $VERSION"
          echo "  PR URL:     https://github.com/${FLATHUB_REPO}/compare/${VERSION}"
          echo "=========================================="

  # ===========================================================================
  # Summary
  # ===========================================================================
  summary:
    name: Build Summary
    needs: [check-trigger, configure, build, create-release, publish-flathub]
    if: always() && needs.check-trigger.outputs.should_build == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Generate summary
        run: |
          BRANCH="${{ needs.configure.outputs.branch }}"
          IS_EPICURE="${{ needs.configure.outputs.is_epicure }}"
          IS_DRY_RUN="${{ needs.configure.outputs.is_dry_run }}"
          VERSION="${{ needs.build.outputs.version }}"
          RELEASE_REPO="${{ needs.configure.outputs.release_repo }}"
          PUBLISH_FLATHUB="${{ needs.configure.outputs.publish_flathub }}"

          BUILD_RESULT="${{ needs.build.result }}"
          RELEASE_RESULT="${{ needs.create-release.result }}"
          FLATHUB_RESULT="${{ needs.publish-flathub.result }}"

          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "$IS_DRY_RUN" == "true" ]]; then
            echo "**Mode:** Dry run" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | \`${BRANCH}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Epicure | ${IS_EPICURE} |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | \`${VERSION}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Components | \`${{ needs.configure.outputs.components_release }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Release repo | \`${RELEASE_REPO}\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Result |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Build | ${BUILD_RESULT} |" >> $GITHUB_STEP_SUMMARY
          echo "| Release | ${RELEASE_RESULT} |" >> $GITHUB_STEP_SUMMARY

          if [[ "$PUBLISH_FLATHUB" == "true" ]]; then
            echo "| Flathub | ${FLATHUB_RESULT} |" >> $GITHUB_STEP_SUMMARY
          fi
